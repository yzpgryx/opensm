package main

import (
	"bytes"
	"opensm/src/sm3"
	"testing"
)

func TestNew(t *testing.T) {
	data1 := []byte{
		0x61, 0x62, 0x63,
	}

	data2 := []byte{
		0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64,
		0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64,
		0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64,
		0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64,
		0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64,
		0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64,
		0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64,
		0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64,
	}

	hash1 := []byte{
		0x66, 0xC7, 0xF0, 0xF4, 0x62, 0xEE, 0xED, 0xD9,
		0xD1, 0xF2, 0xD4, 0x6B, 0xDC, 0x10, 0xE4, 0xE2,
		0x41, 0x67, 0xC4, 0x87, 0x5C, 0xF2, 0xF7, 0xA2,
		0x29, 0x7D, 0xA0, 0x2B, 0x8F, 0x4B, 0xA8, 0xE0,
	}
	hash2 := []byte{
		0xDE, 0xBE, 0x9F, 0xF9, 0x22, 0x75, 0xB8, 0xA1,
		0x38, 0x60, 0x48, 0x89, 0xC1, 0x8E, 0x5A, 0x4D,
		0x6F, 0xDB, 0x70, 0xE5, 0x38, 0x7E, 0x57, 0x65,
		0x29, 0x3D, 0xCB, 0xA3, 0x9C, 0x0C, 0x57, 0x32,
	}
	sm3 := sm3.New()
	if sm3 == nil {
		t.Errorf("new sm3 failed")
	} else {
		t.Logf("new sm3 success")
	}

	sm3.Write(data1)
	hash := sm3.Sum(nil)

	if bytes.Equal(hash1, hash) {
		t.Logf("%d bytes data write & sum test success\n", len(data1))
	}

	sm3.Reset()
	sm3.Write(data2)
	hash = sm3.Sum(nil)
	if bytes.Equal(hash2, hash) {
		t.Logf("%d bytes data write & sum test success\n", len(data2))
	}

	sm3.Reset()
	hash = sm3.Sum(data1)
	if bytes.Equal(hash1, hash) {
		t.Logf("%d bytes data sum test success\n", len(data1))
	}

	sm3.Reset()
	hash = sm3.Sum(data2)
	if bytes.Equal(hash2, hash) {
		t.Logf("%d bytes data sum test success\n", len(data2))
	}

	sm3.Reset()
	for i := 0; i < len(data2); i++ {
		sm3.Write(data2[i : i+1])
	}
	hash = sm3.Sum(nil)
	if bytes.Equal(hash2, hash) {
		t.Logf("%d bytes data one byte test success\n", len(data2))
	}

	sm3.Reset()
	for i := 0; i < 30; i++ {
		sm3.Write(data2[i : i+1])
	}
	hash = sm3.Sum(data2[30:])
	if bytes.Equal(hash2, hash) {
		t.Logf("%d bytes data mix test success\n", len(data2))
	}

	sm3.Reset()
	for i := 0; i < 32; i++ {
		sm3.Write(data2[i : i+1])
	}
	sm3.Sum(nil)
	sm3.Write(data2[32:])
	hash = sm3.Sum(nil)
	if bytes.Equal(hash2, hash) {
		t.Logf("%d bytes data mix continuously test success\n", len(data2))
	}
}
